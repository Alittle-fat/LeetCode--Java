### 解题思路
> 一开始找不到思路，只能找规律。我发现随着绳子长度的不断增加，如果尽可能多地把绳子切成长为3的子段，那么得到的乘积总是最大的。所以我们可以猜想，是否可以把绳子等长度切分，得到的乘积最大呢？如果成立的话，这个长度是多少？

就是说，假设一个数num=a+b，那么需要比较axb和((a+b)/2) x ((a+b)/2)的大小，如果把num=a+b+c，那么就是比较axbxc和((a+b+c)/3) x ((a+b+c)/3) x ((a+b+c)/3)的大小，由**算术几何均值不等式**：
![不等式.JPG](https://pic.leetcode-cn.com/1620700063-aGPFuY-%E4%B8%8D%E7%AD%89%E5%BC%8F.JPG)
所以可以看出，如果把绳子均分，得到的乘积会更大。

进一步，可以证明：均分得到的乘积是最大的，如下：
![证明1.JPG](https://pic.leetcode-cn.com/1620700089-IWcJzk-%E8%AF%81%E6%98%8E1.JPG)
所以如果把绳子切成每段长为e的子段，得到的乘积最大。由于只能切成整数，

进一步：**结论：把绳子切成等长为3时，得到的乘积最大！**

> 但是不能正好全切成3怎么办？如下有切分原则：
> 最优： 3。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。
> 次优： 2 。若最后一段绳子长度为 2；则保留，不再拆为 1+1 。
> 最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3 + 1替换为 2 + 2，因为 2×2>3×1。 

### 代码

```cpp
class Solution {
public:
    int cuttingRope(int n) {
        //绳长n<=3  返回n-1
        if(n<=3)  return n-1;

        int a=n/3,b=n%3;
        if(b==0)  return pow(3,a);          //否则，如果恰好全切成a份长为3的子段，返回(3)^a
        if(b==1)  return pow(3,a-1)*4;      //余1的话，返回3^(a-1)*4
        return pow(3,a)*2;                  //余2的话，返回3^a*2

        //牛批写法：和三为一：return n <= 3? n - 1 : pow(3, n / 3) * 4 / (4 - n % 3);
    }
};

```
> 时间空间复杂度都为O(1)  仅有求整、求余、次方运算。  且变量 a 和 b 使用常数大小额外空间。

> 回顾贪心算法的思想：每次选择都选最贪婪的那个，在这题中，每切一次都要考量切多长。经过数学证明，存在一个”最优长度“，也就是”最贪婪的那个选择“，即每次都切3。就能得到最终的最优乘积。

参考K神的题解：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/

😊走心题解，大佬们动动小手给个赞吧~