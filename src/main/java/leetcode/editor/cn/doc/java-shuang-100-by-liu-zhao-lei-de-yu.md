**最接近的较小值:二进制表示中从右向左找前面有0的第一个1,"10"中的1,0换位,剩下右边的二进制位前后翻转**
解释:从低位向高位找第一个可以被低位0替换的1使数变小,同时低位在保持0,1个数不变时要尽可能大,分析发现在满足前面查找条件右边的0,1分布:空,"0000"(全是0),“0011”(全1开始全0结束)和“11111”(全是1),只需要把他们前后翻转就能把所有1移动到高位实现剩余右边值最大
**最接近的较大值:二进制表示中从右向左找前面有1的第一个0,"01"中的1,0换位,剩下右边的二进制位前后翻转**
解释:从低位向高位找第一个可以被低位1替换的0使数变大,同时低位在保持0,1个数不变时要尽可能小,分析发现在满足前面查找条件右边的0,1分布:空,"0000"(全是0),“1100”(全0开始全1结束)和“11111”(全是1),只需要把他们前后翻转就能把所有0移动到高位实现剩余边右值最小
代码：

```
public int[] findClosedNumbers(int num) {
        int [] re={-1,-1};
        int flag1=0;
        int flag2=0;
        int temp=num;
        int cur;
        for(int i=0;i<31&&(flag1<2 || flag2<2);i++){
            cur=temp&1;
            temp=temp>>1;
            if(flag1==0&&cur==0){
                flag1=1;
            }else if(flag1==1 && cur==1){
                flag1=2;
                re[1]=(int)(num-Math.pow(2,i)+Math.pow(2,i-1));
                int temp1=re[1]&(((int)Math.pow(2,i-1))-1);
                re[1]=re[1]>>(i-1);
                for(int j=0;j<i-1;j++){
                    re[1]=((re[1]<<1)|(temp1&1));
                    temp1=temp1>>1;
                }
            }
            if(flag2==0&&cur==1){
                flag2=1;
            }else if(flag2==1 && cur==0){
                flag2=2;
                re[0]=(int)(num-Math.pow(2,i-1)+Math.pow(2,i));
                int temp1=re[0]&(((int)Math.pow(2,i-1))-1);
                re[0]=re[0]>>(i-1);
                for(int j=0;j<i-1;j++){
                    re[0]=((re[0]<<1)|(temp1&1));
                    temp1=temp1>>1;
                }
            }
        }
        return re;
    }
```
